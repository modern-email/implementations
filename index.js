"use strict";
// NOTE: GENERATED by github.com/mjl-/sherpats, DO NOT MODIFY
var api;
(function (api) {
	// Implementation status of a feature for software.
	let Status;
	(function (Status) {
		Status["Unknown"] = "";
		Status["NotApplicable"] = "n/a";
		Status["Never"] = "Never";
		Status["No"] = "No";
		Status["Planned"] = "Planned";
		Status["Partial"] = "Partial";
		Status["Yes"] = "Yes";
	})(Status = api.Status || (api.Status = {}));
	api.structTypes = { "Feature": true, "Implementation": true, "Software": true, "State": true };
	api.stringsTypes = { "Status": true };
	api.intsTypes = {};
	api.types = {
		"Implementation": { "Name": "Implementation", "Docs": "", "Fields": [{ "Name": "ID", "Docs": "", "Typewords": ["int64"] }, { "Name": "Updated", "Docs": "", "Typewords": ["timestamp"] }, { "Name": "SoftwareID", "Docs": "", "Typewords": ["string"] }, { "Name": "FeatureID", "Docs": "", "Typewords": ["string"] }, { "Name": "Status", "Docs": "", "Typewords": ["Status"] }, { "Name": "Bugs", "Docs": "", "Typewords": ["bool"] }, { "Name": "Plugin", "Docs": "", "Typewords": ["bool"] }, { "Name": "URL", "Docs": "", "Typewords": ["string"] }, { "Name": "SinceVersion", "Docs": "", "Typewords": ["string"] }, { "Name": "Notes", "Docs": "", "Typewords": ["string"] }] },
		"Software": { "Name": "Software", "Docs": "", "Fields": [{ "Name": "ID", "Docs": "", "Typewords": ["string"] }, { "Name": "Created", "Docs": "", "Typewords": ["timestamp"] }, { "Name": "Updated", "Docs": "", "Typewords": ["timestamp"] }, { "Name": "Name", "Docs": "", "Typewords": ["string"] }, { "Name": "URL", "Docs": "", "Typewords": ["string"] }, { "Name": "Description", "Docs": "", "Typewords": ["string"] }, { "Name": "OpenSource", "Docs": "", "Typewords": ["bool"] }, { "Name": "Maintained", "Docs": "", "Typewords": ["bool"] }, { "Name": "License", "Docs": "", "Typewords": ["string"] }, { "Name": "ProgLang", "Docs": "", "Typewords": ["string"] }, { "Name": "Distribution", "Docs": "", "Typewords": ["bool"] }, { "Name": "Server", "Docs": "", "Typewords": ["bool"] }, { "Name": "Service", "Docs": "", "Typewords": ["bool"] }, { "Name": "Library", "Docs": "", "Typewords": ["bool"] }, { "Name": "Client", "Docs": "", "Typewords": ["bool"] }, { "Name": "Desktop", "Docs": "", "Typewords": ["bool"] }, { "Name": "Mobile", "Docs": "", "Typewords": ["bool"] }, { "Name": "Web", "Docs": "", "Typewords": ["bool"] }, { "Name": "Terminal", "Docs": "", "Typewords": ["bool"] }] },
		"Feature": { "Name": "Feature", "Docs": "", "Fields": [{ "Name": "ID", "Docs": "", "Typewords": ["string"] }, { "Name": "Created", "Docs": "", "Typewords": ["timestamp"] }, { "Name": "Updated", "Docs": "", "Typewords": ["timestamp"] }, { "Name": "Title", "Docs": "", "Typewords": ["string"] }, { "Name": "URL", "Docs": "", "Typewords": ["string"] }, { "Name": "Description", "Docs": "", "Typewords": ["string"] }, { "Name": "Server", "Docs": "", "Typewords": ["bool"] }, { "Name": "Service", "Docs": "", "Typewords": ["bool"] }, { "Name": "Library", "Docs": "", "Typewords": ["bool"] }, { "Name": "Client", "Docs": "", "Typewords": ["bool"] }, { "Name": "Desktop", "Docs": "", "Typewords": ["bool"] }, { "Name": "Mobile", "Docs": "", "Typewords": ["bool"] }, { "Name": "Web", "Docs": "", "Typewords": ["bool"] }, { "Name": "Terminal", "Docs": "", "Typewords": ["bool"] }] },
		"State": { "Name": "State", "Docs": "", "Fields": [{ "Name": "Software", "Docs": "", "Typewords": ["[]", "Software"] }, { "Name": "Features", "Docs": "", "Typewords": ["[]", "Feature"] }, { "Name": "Implementations", "Docs": "", "Typewords": ["[]", "Implementation"] }] },
		"Status": { "Name": "Status", "Docs": "", "Values": [{ "Name": "Unknown", "Value": "", "Docs": "" }, { "Name": "NotApplicable", "Value": "n/a", "Docs": "" }, { "Name": "Never", "Value": "Never", "Docs": "" }, { "Name": "No", "Value": "No", "Docs": "" }, { "Name": "Planned", "Value": "Planned", "Docs": "" }, { "Name": "Partial", "Value": "Partial", "Docs": "" }, { "Name": "Yes", "Value": "Yes", "Docs": "" }] },
	};
	api.parser = {
		Implementation: (v) => api.parse("Implementation", v),
		Software: (v) => api.parse("Software", v),
		Feature: (v) => api.parse("Feature", v),
		State: (v) => api.parse("State", v),
		Status: (v) => api.parse("Status", v),
	};
	let defaultOptions = { slicesNullable: true, mapsNullable: true, nullableOptional: true };
	class Client {
		baseURL;
		authState;
		options;
		constructor() {
			this.authState = {};
			this.options = { ...defaultOptions };
			this.baseURL = this.options.baseURL || api.defaultBaseURL;
		}
		withAuthToken(token) {
			const c = new Client();
			c.authState.token = token;
			c.options = this.options;
			return c;
		}
		withOptions(options) {
			const c = new Client();
			c.authState = this.authState;
			c.options = { ...this.options, ...options };
			return c;
		}
		async ImplementationSet(impl) {
			const fn = "ImplementationSet";
			const paramTypes = [["Implementation"]];
			const returnTypes = [["Implementation"]];
			const params = [impl];
			return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params);
		}
		async ImplementationRemove(id) {
			const fn = "ImplementationRemove";
			const paramTypes = [["int64"]];
			const returnTypes = [];
			const params = [id];
			return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params);
		}
		async SoftwareCreate(s) {
			const fn = "SoftwareCreate";
			const paramTypes = [["Software"]];
			const returnTypes = [];
			const params = [s];
			return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params);
		}
		async SoftwareUpdate(s) {
			const fn = "SoftwareUpdate";
			const paramTypes = [["Software"]];
			const returnTypes = [];
			const params = [s];
			return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params);
		}
		async SoftwareRemove(id) {
			const fn = "SoftwareRemove";
			const paramTypes = [["string"]];
			const returnTypes = [];
			const params = [id];
			return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params);
		}
		async FeatureCreate(f) {
			const fn = "FeatureCreate";
			const paramTypes = [["Feature"]];
			const returnTypes = [];
			const params = [f];
			return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params);
		}
		async FeatureUpdate(f) {
			const fn = "FeatureUpdate";
			const paramTypes = [["Feature"]];
			const returnTypes = [];
			const params = [f];
			return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params);
		}
		async FeatureRemove(id) {
			const fn = "FeatureRemove";
			const paramTypes = [["string"]];
			const returnTypes = [];
			const params = [id];
			return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params);
		}
		async State() {
			const fn = "State";
			const paramTypes = [];
			const returnTypes = [["State"]];
			const params = [];
			return await _sherpaCall(this.baseURL, this.authState, { ...this.options }, paramTypes, returnTypes, fn, params);
		}
	}
	api.Client = Client;
	api.defaultBaseURL = (function () {
		let p = location.pathname;
		if (p && p[p.length - 1] !== '/') {
			let l = location.pathname.split('/');
			l = l.slice(0, l.length - 1);
			p = '/' + l.join('/') + '/';
		}
		return location.protocol + '//' + location.host + p + 'api/';
	})();
	// NOTE: code below is shared between github.com/mjl-/sherpaweb and github.com/mjl-/sherpats.
	// KEEP IN SYNC.
	api.supportedSherpaVersion = 1;
	// verifyArg typechecks "v" against "typewords", returning a new (possibly modified) value for JSON-encoding.
	// toJS indicate if the data is coming into JS. If so, timestamps are turned into JS Dates. Otherwise, JS Dates are turned into strings.
	// allowUnknownKeys configures whether unknown keys in structs are allowed.
	// types are the named types of the API.
	api.verifyArg = (path, v, typewords, toJS, allowUnknownKeys, types, opts) => {
		return new verifier(types, toJS, allowUnknownKeys, opts).verify(path, v, typewords);
	};
	api.parse = (name, v) => api.verifyArg(name, v, [name], true, false, api.types, defaultOptions);
	class verifier {
		types;
		toJS;
		allowUnknownKeys;
		opts;
		constructor(types, toJS, allowUnknownKeys, opts) {
			this.types = types;
			this.toJS = toJS;
			this.allowUnknownKeys = allowUnknownKeys;
			this.opts = opts;
		}
		verify(path, v, typewords) {
			typewords = typewords.slice(0);
			const ww = typewords.shift();
			const error = (msg) => {
				if (path != '') {
					msg = path + ': ' + msg;
				}
				throw new Error(msg);
			};
			if (typeof ww !== 'string') {
				error('bad typewords');
				return; // should not be necessary, typescript doesn't see error always throws an exception?
			}
			const w = ww;
			const ensure = (ok, expect) => {
				if (!ok) {
					error('got ' + JSON.stringify(v) + ', expected ' + expect);
				}
				return v;
			};
			switch (w) {
				case 'nullable':
					if (v === null || v === undefined && this.opts.nullableOptional) {
						return v;
					}
					return this.verify(path, v, typewords);
				case '[]':
					if (v === null && this.opts.slicesNullable || v === undefined && this.opts.slicesNullable && this.opts.nullableOptional) {
						return v;
					}
					ensure(Array.isArray(v), "array");
					return v.map((e, i) => this.verify(path + '[' + i + ']', e, typewords));
				case '{}':
					if (v === null && this.opts.mapsNullable || v === undefined && this.opts.mapsNullable && this.opts.nullableOptional) {
						return v;
					}
					ensure(v !== null || typeof v === 'object', "object");
					const r = {};
					for (const k in v) {
						r[k] = this.verify(path + '.' + k, v[k], typewords);
					}
					return r;
			}
			ensure(typewords.length == 0, "empty typewords");
			const t = typeof v;
			switch (w) {
				case 'any':
					return v;
				case 'bool':
					ensure(t === 'boolean', 'bool');
					return v;
				case 'int8':
				case 'uint8':
				case 'int16':
				case 'uint16':
				case 'int32':
				case 'uint32':
				case 'int64':
				case 'uint64':
					ensure(t === 'number' && Number.isInteger(v), 'integer');
					return v;
				case 'float32':
				case 'float64':
					ensure(t === 'number', 'float');
					return v;
				case 'int64s':
				case 'uint64s':
					ensure(t === 'number' && Number.isInteger(v) || t === 'string', 'integer fitting in float without precision loss, or string');
					return '' + v;
				case 'string':
					ensure(t === 'string', 'string');
					return v;
				case 'timestamp':
					if (this.toJS) {
						ensure(t === 'string', 'string, with timestamp');
						const d = new Date(v);
						if (d instanceof Date && !isNaN(d.getTime())) {
							return d;
						}
						error('invalid date ' + v);
					}
					else {
						ensure(t === 'object' && v !== null, 'non-null object');
						ensure(v.__proto__ === Date.prototype, 'Date');
						return v.toISOString();
					}
			}
			// We're left with named types.
			const nt = this.types[w];
			if (!nt) {
				error('unknown type ' + w);
			}
			if (v === null) {
				error('bad value ' + v + ' for named type ' + w);
			}
			if (api.structTypes[nt.Name]) {
				const t = nt;
				if (typeof v !== 'object') {
					error('bad value ' + v + ' for struct ' + w);
				}
				const r = {};
				for (const f of t.Fields) {
					r[f.Name] = this.verify(path + '.' + f.Name, v[f.Name], f.Typewords);
				}
				// If going to JSON also verify no unknown fields are present.
				if (!this.allowUnknownKeys) {
					const known = {};
					for (const f of t.Fields) {
						known[f.Name] = true;
					}
					Object.keys(v).forEach((k) => {
						if (!known[k]) {
							error('unknown key ' + k + ' for struct ' + w);
						}
					});
				}
				return r;
			}
			else if (api.stringsTypes[nt.Name]) {
				const t = nt;
				if (typeof v !== 'string') {
					error('mistyped value ' + v + ' for named strings ' + t.Name);
				}
				if (!t.Values || t.Values.length === 0) {
					return v;
				}
				for (const sv of t.Values) {
					if (sv.Value === v) {
						return v;
					}
				}
				error('unknkown value ' + v + ' for named strings ' + t.Name);
			}
			else if (api.intsTypes[nt.Name]) {
				const t = nt;
				if (typeof v !== 'number' || !Number.isInteger(v)) {
					error('mistyped value ' + v + ' for named ints ' + t.Name);
				}
				if (!t.Values || t.Values.length === 0) {
					return v;
				}
				for (const sv of t.Values) {
					if (sv.Value === v) {
						return v;
					}
				}
				error('unknkown value ' + v + ' for named ints ' + t.Name);
			}
			else {
				throw new Error('unexpected named type ' + nt);
			}
		}
	}
	const _sherpaCall = async (baseURL, authState, options, paramTypes, returnTypes, name, params) => {
		if (!options.skipParamCheck) {
			if (params.length !== paramTypes.length) {
				return Promise.reject({ message: 'wrong number of parameters in sherpa call, saw ' + params.length + ' != expected ' + paramTypes.length });
			}
			params = params.map((v, index) => api.verifyArg('params[' + index + ']', v, paramTypes[index], false, false, api.types, options));
		}
		const simulate = async (json) => {
			const config = JSON.parse(json || 'null') || {};
			const waitMinMsec = config.waitMinMsec || 0;
			const waitMaxMsec = config.waitMaxMsec || 0;
			const wait = Math.random() * (waitMaxMsec - waitMinMsec);
			const failRate = config.failRate || 0;
			return new Promise((resolve, reject) => {
				if (options.aborter) {
					options.aborter.abort = () => {
						reject({ message: 'call to ' + name + ' aborted by user', code: 'sherpa:aborted' });
						reject = resolve = () => { };
					};
				}
				setTimeout(() => {
					const r = Math.random();
					if (r < failRate) {
						reject({ message: 'injected failure on ' + name, code: 'server:injected' });
					}
					else {
						resolve();
					}
					reject = resolve = () => { };
				}, waitMinMsec + wait);
			});
		};
		// Only simulate when there is a debug string. Otherwise it would always interfere
		// with setting options.aborter.
		let json = '';
		try {
			json = window.localStorage.getItem('sherpats-debug') || '';
		}
		catch (err) { }
		if (json) {
			await simulate(json);
		}
		const fn = (resolve, reject) => {
			let resolve1 = (v) => {
				resolve(v);
				resolve1 = () => { };
				reject1 = () => { };
			};
			let reject1 = (v) => {
				if ((v.code === 'user:noAuth' || v.code === 'user:badAuth') && options.login) {
					const login = options.login;
					if (!authState.loginPromise) {
						authState.loginPromise = new Promise((aresolve, areject) => {
							login(v.code === 'user:badAuth' ? (v.message || '') : '')
								.then((token) => {
								authState.token = token;
								authState.loginPromise = undefined;
								aresolve();
							}, (err) => {
								authState.loginPromise = undefined;
								areject(err);
							});
						});
					}
					authState.loginPromise
						.then(() => {
						fn(resolve, reject);
					}, (err) => {
						reject(err);
					});
					return;
				}
				reject(v);
				resolve1 = () => { };
				reject1 = () => { };
			};
			const url = baseURL + name;
			const req = new window.XMLHttpRequest();
			if (options.aborter) {
				options.aborter.abort = () => {
					req.abort();
					reject1({ code: 'sherpa:aborted', message: 'request aborted' });
				};
			}
			req.open('POST', url, true);
			if (options.csrfHeader && authState.token) {
				req.setRequestHeader(options.csrfHeader, authState.token);
			}
			if (options.timeoutMsec) {
				req.timeout = options.timeoutMsec;
			}
			req.onload = () => {
				if (req.status !== 200) {
					if (req.status === 404) {
						reject1({ code: 'sherpa:badFunction', message: 'function does not exist' });
					}
					else {
						reject1({ code: 'sherpa:http', message: 'error calling function, HTTP status: ' + req.status });
					}
					return;
				}
				let resp;
				try {
					resp = JSON.parse(req.responseText);
				}
				catch (err) {
					reject1({ code: 'sherpa:badResponse', message: 'bad JSON from server' });
					return;
				}
				if (resp && resp.error) {
					const err = resp.error;
					reject1({ code: err.code, message: err.message });
					return;
				}
				else if (!resp || !resp.hasOwnProperty('result')) {
					reject1({ code: 'sherpa:badResponse', message: "invalid sherpa response object, missing 'result'" });
					return;
				}
				if (options.skipReturnCheck) {
					resolve1(resp.result);
					return;
				}
				let result = resp.result;
				try {
					if (returnTypes.length === 0) {
						if (result) {
							throw new Error('function ' + name + ' returned a value while prototype says it returns "void"');
						}
					}
					else if (returnTypes.length === 1) {
						result = api.verifyArg('result', result, returnTypes[0], true, true, api.types, options);
					}
					else {
						if (result.length != returnTypes.length) {
							throw new Error('wrong number of values returned by ' + name + ', saw ' + result.length + ' != expected ' + returnTypes.length);
						}
						result = result.map((v, index) => api.verifyArg('result[' + index + ']', v, returnTypes[index], true, true, api.types, options));
					}
				}
				catch (err) {
					let errmsg = 'bad types';
					if (err instanceof Error) {
						errmsg = err.message;
					}
					reject1({ code: 'sherpa:badTypes', message: errmsg });
				}
				resolve1(result);
			};
			req.onerror = () => {
				reject1({ code: 'sherpa:connection', message: 'connection failed' });
			};
			req.ontimeout = () => {
				reject1({ code: 'sherpa:timeout', message: 'request timeout' });
			};
			req.setRequestHeader('Content-Type', 'application/json');
			try {
				req.send(JSON.stringify({ params: params }));
			}
			catch (err) {
				reject1({ code: 'sherpa:badData', message: 'cannot marshal to JSON' });
			}
		};
		return await new Promise(fn);
	};
})(api || (api = {}));
// Javascript is generated from typescript, do not modify generated javascript because changes will be overwritten.
const [dom, style, attr, prop] = (function () {
	// Start of unicode block (rough approximation of script), from https://www.unicode.org/Public/UNIDATA/Blocks.txt
	const scriptblocks = [0x0000, 0x0080, 0x0100, 0x0180, 0x0250, 0x02B0, 0x0300, 0x0370, 0x0400, 0x0500, 0x0530, 0x0590, 0x0600, 0x0700, 0x0750, 0x0780, 0x07C0, 0x0800, 0x0840, 0x0860, 0x0870, 0x08A0, 0x0900, 0x0980, 0x0A00, 0x0A80, 0x0B00, 0x0B80, 0x0C00, 0x0C80, 0x0D00, 0x0D80, 0x0E00, 0x0E80, 0x0F00, 0x1000, 0x10A0, 0x1100, 0x1200, 0x1380, 0x13A0, 0x1400, 0x1680, 0x16A0, 0x1700, 0x1720, 0x1740, 0x1760, 0x1780, 0x1800, 0x18B0, 0x1900, 0x1950, 0x1980, 0x19E0, 0x1A00, 0x1A20, 0x1AB0, 0x1B00, 0x1B80, 0x1BC0, 0x1C00, 0x1C50, 0x1C80, 0x1C90, 0x1CC0, 0x1CD0, 0x1D00, 0x1D80, 0x1DC0, 0x1E00, 0x1F00, 0x2000, 0x2070, 0x20A0, 0x20D0, 0x2100, 0x2150, 0x2190, 0x2200, 0x2300, 0x2400, 0x2440, 0x2460, 0x2500, 0x2580, 0x25A0, 0x2600, 0x2700, 0x27C0, 0x27F0, 0x2800, 0x2900, 0x2980, 0x2A00, 0x2B00, 0x2C00, 0x2C60, 0x2C80, 0x2D00, 0x2D30, 0x2D80, 0x2DE0, 0x2E00, 0x2E80, 0x2F00, 0x2FF0, 0x3000, 0x3040, 0x30A0, 0x3100, 0x3130, 0x3190, 0x31A0, 0x31C0, 0x31F0, 0x3200, 0x3300, 0x3400, 0x4DC0, 0x4E00, 0xA000, 0xA490, 0xA4D0, 0xA500, 0xA640, 0xA6A0, 0xA700, 0xA720, 0xA800, 0xA830, 0xA840, 0xA880, 0xA8E0, 0xA900, 0xA930, 0xA960, 0xA980, 0xA9E0, 0xAA00, 0xAA60, 0xAA80, 0xAAE0, 0xAB00, 0xAB30, 0xAB70, 0xABC0, 0xAC00, 0xD7B0, 0xD800, 0xDB80, 0xDC00, 0xE000, 0xF900, 0xFB00, 0xFB50, 0xFE00, 0xFE10, 0xFE20, 0xFE30, 0xFE50, 0xFE70, 0xFF00, 0xFFF0, 0x10000, 0x10080, 0x10100, 0x10140, 0x10190, 0x101D0, 0x10280, 0x102A0, 0x102E0, 0x10300, 0x10330, 0x10350, 0x10380, 0x103A0, 0x10400, 0x10450, 0x10480, 0x104B0, 0x10500, 0x10530, 0x10570, 0x10600, 0x10780, 0x10800, 0x10840, 0x10860, 0x10880, 0x108E0, 0x10900, 0x10920, 0x10980, 0x109A0, 0x10A00, 0x10A60, 0x10A80, 0x10AC0, 0x10B00, 0x10B40, 0x10B60, 0x10B80, 0x10C00, 0x10C80, 0x10D00, 0x10E60, 0x10E80, 0x10EC0, 0x10F00, 0x10F30, 0x10F70, 0x10FB0, 0x10FE0, 0x11000, 0x11080, 0x110D0, 0x11100, 0x11150, 0x11180, 0x111E0, 0x11200, 0x11280, 0x112B0, 0x11300, 0x11400, 0x11480, 0x11580, 0x11600, 0x11660, 0x11680, 0x11700, 0x11800, 0x118A0, 0x11900, 0x119A0, 0x11A00, 0x11A50, 0x11AB0, 0x11AC0, 0x11B00, 0x11C00, 0x11C70, 0x11D00, 0x11D60, 0x11EE0, 0x11F00, 0x11FB0, 0x11FC0, 0x12000, 0x12400, 0x12480, 0x12F90, 0x13000, 0x13430, 0x14400, 0x16800, 0x16A40, 0x16A70, 0x16AD0, 0x16B00, 0x16E40, 0x16F00, 0x16FE0, 0x17000, 0x18800, 0x18B00, 0x18D00, 0x1AFF0, 0x1B000, 0x1B100, 0x1B130, 0x1B170, 0x1BC00, 0x1BCA0, 0x1CF00, 0x1D000, 0x1D100, 0x1D200, 0x1D2C0, 0x1D2E0, 0x1D300, 0x1D360, 0x1D400, 0x1D800, 0x1DF00, 0x1E000, 0x1E030, 0x1E100, 0x1E290, 0x1E2C0, 0x1E4D0, 0x1E7E0, 0x1E800, 0x1E900, 0x1EC70, 0x1ED00, 0x1EE00, 0x1F000, 0x1F030, 0x1F0A0, 0x1F100, 0x1F200, 0x1F300, 0x1F600, 0x1F650, 0x1F680, 0x1F700, 0x1F780, 0x1F800, 0x1F900, 0x1FA00, 0x1FA70, 0x1FB00, 0x20000, 0x2A700, 0x2B740, 0x2B820, 0x2CEB0, 0x2F800, 0x30000, 0x31350, 0xE0000, 0xE0100, 0xF0000, 0x100000];
	// Find block code belongs in.
	const findBlock = (code) => {
		let s = 0;
		let e = scriptblocks.length;
		while (s < e - 1) {
			let i = Math.floor((s + e) / 2);
			if (code < scriptblocks[i]) {
				e = i;
			}
			else {
				s = i;
			}
		}
		return s;
	};
	// formatText adds s to element e, in a way that makes switching unicode scripts
	// clear, with alternating DOM TextNode and span elements with a "switchscript"
	// class. Useful for highlighting look alikes, e.g. a (ascii 0x61) and Ð° (cyrillic
	// 0x430).
	//
	// This is only called one string at a time, so the UI can still display strings
	// without highlighting switching scripts, by calling formatText on the parts.
	const formatText = (e, s) => {
		// Handle some common cases quickly.
		if (!s) {
			return;
		}
		let ascii = true;
		for (const c of s) {
			const cp = c.codePointAt(0); // For typescript, to check for undefined.
			if (cp !== undefined && cp >= 0x0080) {
				ascii = false;
				break;
			}
		}
		if (ascii) {
			e.appendChild(document.createTextNode(s));
			return;
		}
		// todo: handle grapheme clusters? wait for Intl.Segmenter?
		let n = 0; // Number of text/span parts added.
		let str = ''; // Collected so far.
		let block = -1; // Previous block/script.
		let mod = 1;
		const put = (nextblock) => {
			if (n === 0 && nextblock === 0) {
				// Start was non-ascii, second block is ascii, we'll start marked as switched.
				mod = 0;
			}
			if (n % 2 === mod) {
				const x = document.createElement('span');
				x.classList.add('scriptswitch');
				x.appendChild(document.createTextNode(str));
				e.appendChild(x);
			}
			else {
				e.appendChild(document.createTextNode(str));
			}
			n++;
			str = '';
		};
		for (const c of s) {
			// Basic whitespace does not switch blocks. Will probably need to extend with more
			// punctuation in the future. Possibly for digits too. But perhaps not in all
			// scripts.
			if (c === ' ' || c === '\t' || c === '\r' || c === '\n') {
				str += c;
				continue;
			}
			const code = c.codePointAt(0);
			if (block < 0 || !(code >= scriptblocks[block] && (code < scriptblocks[block + 1] || block === scriptblocks.length - 1))) {
				const nextblock = code < 0x0080 ? 0 : findBlock(code);
				if (block >= 0) {
					put(nextblock);
				}
				block = nextblock;
			}
			str += c;
		}
		put(-1);
	};
	const _domKids = (e, l) => {
		l.forEach((c) => {
			const xc = c;
			if (typeof c === 'string') {
				formatText(e, c);
			}
			else if (c instanceof String) {
				// String is an escape-hatch for text that should not be formatted with
				// unicode-block-change-highlighting, e.g. for textarea values.
				e.appendChild(document.createTextNode('' + c));
			}
			else if (c instanceof Element) {
				e.appendChild(c);
			}
			else if (c instanceof Function) {
				if (!c.name) {
					throw new Error('function without name');
				}
				e.addEventListener(c.name, c);
			}
			else if (Array.isArray(xc)) {
				_domKids(e, c);
			}
			else if (xc._class) {
				for (const s of xc._class) {
					e.classList.toggle(s, true);
				}
			}
			else if (xc._attrs) {
				for (const k in xc._attrs) {
					e.setAttribute(k, xc._attrs[k]);
				}
			}
			else if (xc._styles) {
				for (const k in xc._styles) {
					const estyle = e.style;
					estyle[k] = xc._styles[k];
				}
			}
			else if (xc._props) {
				for (const k in xc._props) {
					const eprops = e;
					eprops[k] = xc._props[k];
				}
			}
			else if (xc.root) {
				e.appendChild(xc.root);
			}
			else {
				console.log('bad kid', c);
				throw new Error('bad kid');
			}
		});
		return e;
	};
	const dom = {
		_kids: function (e, ...kl) {
			while (e.firstChild) {
				e.removeChild(e.firstChild);
			}
			_domKids(e, kl);
		},
		_attrs: (x) => { return { _attrs: x }; },
		_class: (...x) => { return { _class: x }; },
		// The createElement calls are spelled out so typescript can derive function
		// signatures with a specific HTML*Element return type.
		div: (...l) => _domKids(document.createElement('div'), l),
		span: (...l) => _domKids(document.createElement('span'), l),
		a: (...l) => _domKids(document.createElement('a'), l),
		input: (...l) => _domKids(document.createElement('input'), l),
		textarea: (...l) => _domKids(document.createElement('textarea'), l),
		select: (...l) => _domKids(document.createElement('select'), l),
		option: (...l) => _domKids(document.createElement('option'), l),
		clickbutton: (...l) => _domKids(document.createElement('button'), [attr.type('button'), ...l]),
		submitbutton: (...l) => _domKids(document.createElement('button'), [attr.type('submit'), ...l]),
		form: (...l) => _domKids(document.createElement('form'), l),
		fieldset: (...l) => _domKids(document.createElement('fieldset'), l),
		table: (...l) => _domKids(document.createElement('table'), l),
		thead: (...l) => _domKids(document.createElement('thead'), l),
		tbody: (...l) => _domKids(document.createElement('tbody'), l),
		tfoot: (...l) => _domKids(document.createElement('tfoot'), l),
		tr: (...l) => _domKids(document.createElement('tr'), l),
		td: (...l) => _domKids(document.createElement('td'), l),
		th: (...l) => _domKids(document.createElement('th'), l),
		datalist: (...l) => _domKids(document.createElement('datalist'), l),
		h1: (...l) => _domKids(document.createElement('h1'), l),
		h2: (...l) => _domKids(document.createElement('h2'), l),
		h3: (...l) => _domKids(document.createElement('h3'), l),
		br: (...l) => _domKids(document.createElement('br'), l),
		hr: (...l) => _domKids(document.createElement('hr'), l),
		pre: (...l) => _domKids(document.createElement('pre'), l),
		label: (...l) => _domKids(document.createElement('label'), l),
		ul: (...l) => _domKids(document.createElement('ul'), l),
		li: (...l) => _domKids(document.createElement('li'), l),
		iframe: (...l) => _domKids(document.createElement('iframe'), l),
		b: (...l) => _domKids(document.createElement('b'), l),
		img: (...l) => _domKids(document.createElement('img'), l),
		style: (...l) => _domKids(document.createElement('style'), l),
		search: (...l) => _domKids(document.createElement('search'), l),
		p: (...l) => _domKids(document.createElement('p'), l),
	};
	const _attr = (k, v) => { const o = {}; o[k] = v; return { _attrs: o }; };
	const attr = {
		title: (s) => _attr('title', s),
		value: (s) => _attr('value', s),
		type: (s) => _attr('type', s),
		tabindex: (s) => _attr('tabindex', s),
		src: (s) => _attr('src', s),
		placeholder: (s) => _attr('placeholder', s),
		href: (s) => _attr('href', s),
		checked: (s) => _attr('checked', s),
		selected: (s) => _attr('selected', s),
		id: (s) => _attr('id', s),
		datalist: (s) => _attr('datalist', s),
		rows: (s) => _attr('rows', s),
		target: (s) => _attr('target', s),
		rel: (s) => _attr('rel', s),
		required: (s) => _attr('required', s),
		multiple: (s) => _attr('multiple', s),
		download: (s) => _attr('download', s),
		disabled: (s) => _attr('disabled', s),
		draggable: (s) => _attr('draggable', s),
		rowspan: (s) => _attr('rowspan', s),
		colspan: (s) => _attr('colspan', s),
		for: (s) => _attr('for', s),
		role: (s) => _attr('role', s),
		arialabel: (s) => _attr('aria-label', s),
		arialive: (s) => _attr('aria-live', s),
		name: (s) => _attr('name', s),
		min: (s) => _attr('min', s),
		max: (s) => _attr('max', s),
		action: (s) => _attr('action', s),
		method: (s) => _attr('method', s),
		autocomplete: (s) => _attr('autocomplete', s),
	};
	const style = (x) => { return { _styles: x }; };
	const prop = (x) => { return { _props: x }; };
	return [dom, style, attr, prop];
})();
const client = new api.Client();
const errmsg = (err) => '' + (err.message || '(no error message)');
let popupOpen = false;
const popup = (...kids) => {
	const origFocus = document.activeElement;
	const close = (discard = false) => {
		if (!root.parentNode) {
			return;
		}
		if (discard && Array.prototype.some.call(content.querySelectorAll('input, textarea'), (e) => {
			if (e instanceof HTMLTextAreaElement || e.type === 'text') {
				return e.value !== e.defaultValue;
			}
			return e.checked !== e.defaultChecked;
		}) && !window.confirm('Close & discard edits?')) {
			return;
		}
		popupOpen = false;
		root.remove();
		if (origFocus && origFocus instanceof HTMLElement && origFocus.parentNode) {
			origFocus.focus();
		}
	};
	let content;
	let mousedownTarget;
	const root = dom.div(style({ position: 'fixed', top: 0, right: 0, bottom: 0, left: 0, backgroundColor: 'rgba(0, 0, 0, 0.1)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 2 }), function keydown(e) {
		if (e.key === 'Escape') {
			e.stopPropagation();
			close(true);
		}
	}, function mousedown(e) {
		if (e.target) {
			mousedownTarget = e.target;
		}
	}, function click(e) {
		e.stopPropagation();
		if (e.target === mousedownTarget) {
			close(true);
		}
	}, content = dom.div(attr.tabindex('0'), style({ backgroundColor: 'white', borderRadius: '.25em', padding: '1em', boxShadow: '0 0 20px rgba(0, 0, 0, 0.1)', border: '1px solid #ddd', maxWidth: '95vw', overflowX: 'auto', maxHeight: '95vh', overflowY: 'auto' }), function click(e) {
		e.stopPropagation();
	}, kids));
	popupOpen = true;
	document.body.appendChild(root);
	content.focus();
	return close;
};
const formatDate = (d) => d.toLocaleDateString() + ' ' + d.toLocaleTimeString();
// localstorage that ignores errors (e.g. in private mode).
const localStorageGet = (k) => {
	try {
		return JSON.parse(window.localStorage.getItem(k) || '');
	}
	catch (err) {
		return '';
	}
};
const localStorageSet = (k, v) => {
	try {
		window.localStorage.setItem(k, JSON.stringify(v));
	}
	catch (err) { }
};
const featurePopup = async (f, state, render) => {
	let fieldset;
	let id;
	let title;
	let url;
	let description;
	let server;
	let service;
	let library;
	let xclient;
	let desktop;
	let mobile;
	let web;
	let terminal;
	const close = popup(style({ maxWidth: '50em' }), f.ID ? dom.div(style({ textAlign: 'right' }), dom.clickbutton('Remove', async function click(e) {
		if (window.confirm('Are you sure?')) {
			e.target.disabled = true;
			try {
				await client.FeatureRemove(f.ID);
				const i = (state.Features || []).indexOf(f);
				(state.Features || []).splice(i, 1);
				render();
				close();
			}
			catch (err) {
				window.alert('Error: ' + errmsg(err));
			}
			finally {
				e.target.disabled = false;
			}
		}
	})) : [], dom.h1(f.ID ? 'Edit feature' : 'New feature'), dom.p('A feature is either a protocol/standard, or specific functionality thereof, or behaviour of an application. Making a proper ontology of features is hard. Try to stick to existing naming conventions. IDs are hierarchical, dot-separated, with more specific functionality more deeply nested.'), dom.form(async function submit(e) {
		e.preventDefault();
		e.stopPropagation();
		try {
			fieldset.disabled = true;
			const nf = {
				ID: id.value,
				Created: f.Created,
				Updated: new Date(),
				Title: title.value,
				URL: url.value,
				Description: description.value,
				Server: server.checked,
				Service: service.checked,
				Library: library.checked,
				Client: xclient.checked,
				Desktop: desktop.checked,
				Mobile: mobile.checked,
				Web: web.checked,
				Terminal: terminal.checked,
			};
			if (f.ID) {
				await client.FeatureUpdate(nf);
				const i = (state.Features || []).indexOf(f);
				(state.Features || []).splice(i, 1, nf);
			}
			else {
				await client.FeatureCreate(nf);
				if (!state.Features) {
					state.Features = [];
				}
				state.Features.push(nf);
			}
			render();
			close();
		}
		catch (err) {
			window.alert('Error: ' + errmsg(err));
		}
		finally {
			fieldset.disabled = false;
		}
	}, fieldset = dom.fieldset(dom.label(dom.div('ID *'), id = dom.input(attr.required(''), f.ID ? attr.disabled('') : [], attr.value(f.ID)), dom.div(dom._class('explain'), 'Use camelCase identifiers (a-zA-Z0-9 only, for use in JS), dot-separated (by topic). Example: dkim.ed25519.sign')), dom.label(dom.div('Title *'), title = dom.input(attr.required(''), attr.value(f.Title))), dom.label(dom.div('Website URL'), url = dom.input(attr.value(f.URL))), dom.label(dom.div('Description'), description = dom.textarea(f.Description)), dom.br(), dom.div(dom._class('explain'), 'Indicate for which kind of software this feature is applicable. Filtering by these fields applies to both features and software. It helps keep the displayed matrix understandable. ', dom.clickbutton('Check all', function click() {
		for (const e of [server, service, library, xclient, desktop, mobile, web, terminal]) {
			e.checked = true;
		}
	})), dom.label(server = dom.input(attr.type('checkbox'), f.Server ? attr.checked('') : []), ' Server', attr.title('Software that you can run as server.')), dom.label(service = dom.input(attr.type('checkbox'), f.Service ? attr.checked('') : []), ' Service', attr.title('Software that is (only) available as an online service, not for running separately.')), dom.label(library = dom.input(attr.type('checkbox'), f.Library ? attr.checked('') : []), ' Library'), dom.label(xclient = dom.input(attr.type('checkbox'), f.Client ? attr.checked('') : []), ' Client'), dom.label(desktop = dom.input(attr.type('checkbox'), f.Desktop ? attr.checked('') : []), ' Desktop'), dom.label(mobile = dom.input(attr.type('checkbox'), f.Mobile ? attr.checked('') : []), ' Mobile'), dom.label(web = dom.input(attr.type('checkbox'), f.Web ? attr.checked('') : []), ' Web'), dom.label(terminal = dom.input(attr.type('checkbox'), f.Terminal ? attr.checked('') : []), ' Terminal'), dom.br(), dom.div(dom.submitbutton(f.ID ? 'Save feature' : 'Add feature')), dom.br(), dom.div(dom._class('explain'), 'Required fields are marked with "*".'), f.ID ? dom.div('Last updated: ' + formatDate(f.Updated)) : [])));
	id.focus();
};
const softwarePopup = async (s, state, render) => {
	let fieldset;
	let id;
	let name;
	let url;
	let description;
	let openSource;
	let maintained;
	let license;
	let progLang;
	let distribution;
	let server;
	let service;
	let library;
	let xclient;
	let desktop;
	let mobile;
	let web;
	let terminal;
	const close = popup(style({ maxWidth: '50em' }), s.ID ? dom.div(style({ textAlign: 'right' }), dom.clickbutton('Remove', async function click(e) {
		if (window.confirm('Are you sure?')) {
			e.target.disabled = true;
			try {
				await client.SoftwareRemove(s.ID);
				const i = (state.Software || []).indexOf(s);
				(state.Software || []).splice(i, 1);
				render();
				close();
			}
			catch (err) {
				window.alert('Error: ' + errmsg(err));
			}
			finally {
				e.target.disabled = false;
			}
		}
	})) : [], dom.h1(s.ID ? 'Edit software' : 'New software'), dom.form(async function submit(e) {
		e.preventDefault();
		e.stopPropagation();
		try {
			fieldset.disabled = true;
			const ns = {
				ID: id.value,
				Created: s.Created,
				Updated: new Date(),
				Name: name.value,
				URL: url.value,
				Description: description.value,
				OpenSource: openSource.checked,
				Maintained: maintained.checked,
				License: license.value,
				ProgLang: progLang.value,
				Distribution: distribution.checked,
				Server: server.checked,
				Service: service.checked,
				Library: library.checked,
				Client: xclient.checked,
				Desktop: desktop.checked,
				Mobile: mobile.checked,
				Web: web.checked,
				Terminal: terminal.checked,
			};
			if (s.ID) {
				await client.SoftwareUpdate(ns);
				const i = (state.Software || []).indexOf(s);
				(state.Software || []).splice(i, 1, ns);
			}
			else {
				await client.SoftwareCreate(ns);
				if (!state.Software) {
					state.Software = [];
				}
				state.Software.push(ns);
			}
			render();
			close();
		}
		catch (err) {
			window.alert('Error: ' + errmsg(err));
		}
		finally {
			fieldset.disabled = false;
		}
	}, fieldset = dom.fieldset(dom.div(dom.label(dom.div('ID *'), id = dom.input(attr.required(''), attr.value(s.ID), s.ID ? attr.disabled('') : []), dom.div(dom._class('explain'), 'Use camelCase identifiers (a-zA-Z0-9 only, for use in JS).'))), dom.label(dom.div('Name *'), name = dom.input(attr.required(''), attr.value(s.Name))), dom.label(dom.div('Website URL'), url = dom.input(attr.value(s.URL))), dom.label(dom.div('Description'), description = dom.textarea(s.Description)), dom.label(openSource = dom.input(attr.type('checkbox'), s.OpenSource ? attr.checked('') : []), ' Open Source'), dom.label(maintained = dom.input(attr.type('checkbox'), s.Maintained ? attr.checked('') : []), ' Maintained', attr.title('Releases or changes have been made recently. For example in the past 2 years.')), dom.label(dom.div('License'), license = dom.input(attr.value(s.License))), dom.label(dom.div('Programming language(s)'), progLang = dom.input(attr.value(s.ProgLang))), dom.label(distribution = dom.input(attr.type('checkbox'), s.Distribution ? attr.checked('') : []), ' Distribution (of other software packages)'), dom.br(), dom.div(dom._class('explain'), 'Indicate for which kind of software this is. Filtering by these fields applies to both features and software. It helps keep the displayed matrix understandable.'), dom.label(server = dom.input(attr.type('checkbox'), s.Server ? attr.checked('') : []), ' Server', attr.title('Software that you can run as server.')), dom.label(service = dom.input(attr.type('checkbox'), s.Service ? attr.checked('') : []), ' Service', attr.title('Software that is (only) available as an online service, not for running separately.')), dom.label(library = dom.input(attr.type('checkbox'), s.Library ? attr.checked('') : []), ' Library'), dom.label(xclient = dom.input(attr.type('checkbox'), s.Client ? attr.checked('') : []), ' Client'), dom.label(desktop = dom.input(attr.type('checkbox'), s.Desktop ? attr.checked('') : []), ' Desktop'), dom.label(mobile = dom.input(attr.type('checkbox'), s.Mobile ? attr.checked('') : []), ' Mobile'), dom.label(web = dom.input(attr.type('checkbox'), s.Web ? attr.checked('') : []), ' Web'), dom.label(terminal = dom.input(attr.type('checkbox'), s.Terminal ? attr.checked('') : []), ' Terminal'), dom.br(), dom.div(dom.submitbutton(s.ID ? 'Save software' : 'Add software')), dom.br(), dom.div(dom._class('explain'), 'Required fields are marked with "*".'), s.ID ? dom.div('Last updated: ' + formatDate(s.Updated)) : [])));
	id.focus();
};
const implementationPopup = (s, f, implementations, render) => {
	const key = s.ID + ',' + f.ID;
	const impl = implementations.get(key);
	let fieldset;
	let bugs;
	let plugin;
	let url;
	let sinceVersion;
	let notes;
	const save = async () => {
		try {
			fieldset.disabled = true;
			let nimpl = {
				ID: impl?.ID || 0,
				Updated: new Date(),
				SoftwareID: s.ID,
				FeatureID: f.ID,
				Status: fieldset.querySelector('input[name="status"]:checked').value,
				Bugs: bugs.checked,
				Plugin: plugin.checked,
				URL: url.value,
				SinceVersion: sinceVersion.value,
				Notes: notes.value,
			};
			nimpl = await client.ImplementationSet(nimpl);
			implementations.set(key, nimpl);
			render();
			close();
		}
		catch (err) {
			window.alert('Error: ' + errmsg(err));
		}
		finally {
			fieldset.disabled = false;
		}
	};
	const close = popup(style({ maxWidth: '50em' }), dom.h1('Implementation'), dom.div('Software ID: ' + s.ID), dom.div('Feature ID: ' + f.ID), dom.br(), dom.form(function submit(e) {
		e.preventDefault();
		e.stopPropagation();
		save();
	}, fieldset = dom.fieldset(dom.b('Status'), dom.div(dom._class('explain'), 'Double click to immediately save and close the popup.'), dom.div(function dblclick() {
		save();
	}, dom.label(dom.input(attr.type('radio'), attr.name('status'), attr.value(api.Status.Yes), impl?.Status === api.Status.Yes ? attr.checked('') : []), ' ', api.Status.Yes), dom.label(dom.input(attr.type('radio'), attr.name('status'), attr.value(api.Status.Partial), impl?.Status === api.Status.Partial ? attr.checked('') : []), ' ', api.Status.Partial), dom.label(dom.input(attr.type('radio'), attr.name('status'), attr.value(api.Status.Planned), impl?.Status === api.Status.Planned ? attr.checked('') : []), ' ', api.Status.Planned), dom.label(dom.input(attr.type('radio'), attr.name('status'), attr.value(api.Status.No), impl?.Status === api.Status.No ? attr.checked('') : []), ' ', api.Status.No), dom.label(dom.input(attr.type('radio'), attr.name('status'), attr.value(api.Status.Never), impl?.Status === api.Status.Never ? attr.checked('') : []), ' ', api.Status.Never), dom.label(dom.input(attr.type('radio'), attr.name('status'), attr.value(api.Status.NotApplicable), impl?.Status === api.Status.NotApplicable ? attr.checked('') : []), ' N/A'), dom.label(dom.input(attr.type('radio'), attr.name('status'), attr.value(api.Status.Unknown), impl?.Status === api.Status.Unknown ? attr.checked('') : []), ' ', 'Unknown')), dom.br(), dom.label(bugs = dom.input(attr.type('checkbox'), impl?.Bugs ? attr.checked('') : []), ' Known bugs'), dom.label(plugin = dom.input(attr.type('checkbox'), impl?.Plugin ? attr.checked('') : []), ' Support through plugin'), dom.br(), dom.label(dom.div('URL'), url = dom.input(attr.value(impl?.URL || ''))), dom.label(dom.div('Since version'), sinceVersion = dom.input(attr.value(impl?.SinceVersion || ''))), dom.label(dom.div('Notes'), notes = dom.textarea(impl?.Notes || '')), dom.br(), dom.div(dom.submitbutton('Save')), dom.br(), impl?.ID ? dom.div('Last updated: ' + formatDate(impl.Updated)) : [])));
};
const isRelevant = (s, f) => {
	const opts = [
		[s.Server, f.Server],
		[s.Service, f.Service],
		[s.Library, f.Library],
		[s.Client, f.Client],
		[s.Desktop, f.Desktop],
		[s.Web, f.Web],
		[s.Terminal, f.Terminal],
		[s.Mobile, f.Mobile],
	];
	for (const t of opts) {
		if (t[0] && t[1]) {
			return true;
		}
	}
	return false;
};
const softwareSummary = (s) => {
	const kinds = [];
	const check = (v, s) => {
		if (v) {
			kinds.push(s);
		}
	};
	check(s.Server, 'Server');
	check(s.Service, 'Service');
	check(s.Library, 'Library');
	check(s.Client, 'Client');
	check(s.Desktop, 'Desktop');
	check(s.Mobile, 'Mobile');
	check(s.Web, 'Web');
	check(s.Terminal, 'Terminal');
	return [
		['ID', s.ID],
		['Name', s.Name],
		['Maintained', s.Maintained ? 'Yes' : 'No'],
		['License', s.OpenSource ? 'Open Source' : 'Proprietary' + (s.License ? ': ' + s.License : '')],
		['Language(s)', s.ProgLang],
		['Kind', kinds.join(', ')],
		['URL', s.URL],
		['Description', s.Description],
	].filter(t => t[1]).map(t => t[0] + ': ' + t[1]).join('\n');
};
const featureSummary = (f) => {
	const kinds = [];
	const check = (v, s) => {
		if (v) {
			kinds.push(s);
		}
	};
	check(f.Server, 'Server');
	check(f.Service, 'Service');
	check(f.Library, 'Library');
	check(f.Client, 'Client');
	check(f.Desktop, 'Desktop');
	check(f.Mobile, 'Mobile');
	check(f.Web, 'Web');
	check(f.Terminal, 'Terminal');
	return [
		['ID', f.ID],
		['Title', f.Title],
		['Kind', kinds.join(', ')],
		['URL', f.URL],
		['Description', f.Description],
	].filter(t => t[1]).map(t => t[0] + ': ' + t[1]).join('\n');
};
const init = async () => {
	const state = await client.State();
	const implementations = new Map();
	(state.Implementations || []).forEach(impl => {
		implementations.set(impl.SoftwareID + ',' + impl.FeatureID, impl);
	});
	console.log(state);
	let table;
	let search;
	let featureMatch;
	let softwareIDs;
	let filterServer;
	let filterService;
	let filterLibrary;
	let filterClient;
	let filterDesktop;
	let filterMobile;
	let filterWeb;
	let filterTerminal;
	let filterOpenSource;
	let filterUnmaintained;
	let detailsFeatures;
	let detailsSoftware;
	let showIDs;
	let paint;
	const makeStatus = (s, f) => {
		const k = s.ID + ',' + f.ID;
		const impl = implementations.get(k);
		const status = impl?.Status || api.Status.Unknown;
		return dom.td(dom._class('status'), dom._class(status.replace('n/a', 'na').toLowerCase() || 'unknown'), impl?.Bugs ? style({ borderColor: 'red' }) : [], impl?.Plugin ? style({ borderStyle: 'dashed' }) : [], async function click() {
			if (statusPaint === undefined) {
				implementationPopup(s, f, implementations, render);
				return;
			}
			const origStatus = impl?.Status;
			let nimpl = impl || {
				ID: 0,
				SoftwareID: s.ID,
				FeatureID: f.ID,
				Updated: new Date(),
				Status: statusPaint,
				Bugs: false,
				Plugin: false,
				URL: '',
				SinceVersion: '',
				Notes: '',
			};
			nimpl.Status = statusPaint;
			try {
				nimpl = await client.ImplementationSet(nimpl);
			}
			catch (err) {
				window.alert('Error: ' + errmsg(err));
				if (origStatus !== undefined) {
					nimpl.Status = origStatus;
				}
				return;
			}
			if (!impl) {
				implementations.set(k, nimpl);
			}
			render();
			return;
		}, impl?.Notes ? attr.title('Notes: ' + impl?.Notes) : [], status === api.Status.Unknown && isRelevant(s, f) ? '?' : status);
	};
	const checkFilters = (e) => {
		return (!filterServer.checked || e.Server) &&
			(!filterService.checked || e.Service) &&
			(!filterLibrary.checked || e.Library) &&
			(!filterClient.checked || e.Client) &&
			(!filterDesktop.checked || e.Desktop) &&
			(!filterMobile.checked || e.Mobile) &&
			(!filterWeb.checked || e.Web) &&
			(!filterTerminal.checked || e.Terminal);
	};
	const updateHash = () => {
		const qs = new URLSearchParams();
		const input = (e, k) => {
			if (e.value) {
				qs.set(k, e.value);
			}
		};
		const checkbox = (e, k) => {
			if (e.checked) {
				qs.set(k, '');
			}
		};
		input(search, 'text');
		input(featureMatch, 'feats');
		input(softwareIDs, 'software');
		checkbox(filterServer, 'server');
		checkbox(filterService, 'service');
		checkbox(filterLibrary, 'library');
		checkbox(filterClient, 'client');
		checkbox(filterDesktop, 'desktop');
		checkbox(filterMobile, 'mobile');
		checkbox(filterWeb, 'web');
		checkbox(filterTerminal, 'terminal');
		checkbox(filterOpenSource, 'opensource');
		checkbox(filterUnmaintained, 'unmaintained');
		checkbox(detailsFeatures, 'detailfeats');
		checkbox(detailsSoftware, 'detailsoftware');
		let s = qs.toString();
		if (!s) {
			s = '#' + s;
		}
		window.location.hash = s;
		localStorageSet('showids', showIDs.checked);
	};
	const loadFromHash = () => {
		const qs = new URLSearchParams(decodeURIComponent(window.location.hash.substring(1) || ''));
		console.log('qs', qs);
		search.value = qs.get('text') || '';
		featureMatch.value = qs.get('feats') || '';
		softwareIDs.value = qs.get('software') || '';
		filterServer.checked = qs.has('server');
		filterService.checked = qs.has('service');
		filterLibrary.checked = qs.has('library');
		filterClient.checked = qs.has('client');
		filterDesktop.checked = qs.has('desktop');
		filterMobile.checked = qs.has('mobile');
		filterWeb.checked = qs.has('web');
		filterTerminal.checked = qs.has('terminal');
		filterOpenSource.checked = qs.has('opensource');
		filterUnmaintained.checked = qs.has('unmaintained');
		detailsFeatures.checked = qs.has('detailfeats');
		detailsSoftware.checked = qs.has('detailsoftware');
	};
	const changed = () => {
		updateHash();
		render();
	};
	const render = () => {
		console.log('render', state);
		const textSearch = search.value.toLowerCase();
		const matchTextFeature = (f) => {
			if (!textSearch) {
				return true;
			}
			const x = f;
			for (const k in x) {
				if (typeof x[k] === 'string' && x[k].toLowerCase().includes(textSearch)) {
					return true;
				}
			}
			for (const [_, impl] of implementations) {
				if (f.ID !== impl.FeatureID) {
					continue;
				}
				const y = impl;
				for (const k in y) {
					if (typeof y[k] === 'string' && y[k].toLowerCase().includes(textSearch)) {
						return true;
					}
				}
			}
			return false;
		};
		let softIDs;
		if (softwareIDs.value) {
			softIDs = new Set();
			for (const id of softwareIDs.value.split(',')) {
				softIDs.add(id);
			}
		}
		const software = (state.Software || []).filter(s => checkFilters(s) && (!filterOpenSource.checked || s.OpenSource) && (filterUnmaintained.checked || s.Maintained) && (!softIDs || softIDs.has(s.ID)));
		const featregex = featureMatch.value ? new RegExp(featureMatch.value) : undefined;
		const features = (state.Features || []).filter(f => checkFilters(f) && (!featregex || featregex.test(f.ID)) && matchTextFeature(f));
		software.sort((a, b) => a.ID < b.ID ? -1 : 1);
		features.sort((a, b) => a.ID < b.ID ? -1 : 1);
		const ntable = dom.table(dom.thead(style({ position: 'sticky', top: '0', backgroundColor: 'white', zIndex: 2 }), dom.tr(dom.td(style({ verticalAlign: 'bottom' }), dom.div(dom.label(showIDs = dom.input(attr.type('checkbox'), localStorageGet('showids') ? attr.checked('') : [], function change() { changed(); }), ' IDs instead of titles', attr.title('Show IDs of features and software in the first column/row, instead of titles/names. Can be easier when editing and finding the correct IDs to use.'))), dom.div(style({ textAlign: 'right', fontWeight: 'bold', marginTop: '1ex' }), 'Features ', dom.clickbutton('+', attr.title('Add feature'), function click() {
			const nf = {
				ID: '',
				Created: new Date(),
				Updated: new Date(),
				Title: '',
				URL: '',
				Description: '',
				Server: false,
				Service: false,
				Library: false,
				Client: false,
				Desktop: false,
				Web: false,
				Terminal: false,
				Mobile: false,
			};
			featurePopup(nf, state, render);
		}), ' \\ Software ', dom.clickbutton('+', attr.title('Add software'), function click() {
			const ns = {
				ID: '',
				Created: new Date(),
				Updated: new Date(),
				Name: '',
				URL: '',
				Description: '',
				OpenSource: false,
				Maintained: true,
				License: '',
				ProgLang: '',
				Distribution: false,
				Server: false,
				Service: false,
				Library: false,
				Client: false,
				Desktop: false,
				Web: false,
				Terminal: false,
				Mobile: false,
			};
			softwarePopup(ns, state, render);
		}))), detailsFeatures.checked ? dom.td() : [], software.map(s => dom.td(dom._class('software'), dom._class('rotate'), function click() {
			softwarePopup(s, state, render);
		}, dom.div(dom.span(showIDs.checked ? s.ID : s.Name, attr.title(softwareSummary(s)))))))), dom.tbody(dom.tr(dom.td(), detailsFeatures.checked ? dom.td() : [], software.map(s => dom.td(style({ maxWidth: '20em', fontSize: '.8em' }), detailsSoftware.checked ? dom.div('ID: ' + s.ID) : [], s.URL ? [' ', dom.a(attr.href(s.URL), attr.rel('noopener'), attr.title('Open website'), 'ð')] : [], detailsSoftware.checked ? [
			s.Description ? dom.div(s.Description) : [],
			dom.div(s.OpenSource ? 'Open source' : 'Proprietary'),
			dom.div(s.Maintained ? 'Maintained' : 'Unmaintained'),
			s.License ? dom.div('License: ' + s.License) : [],
			s.ProgLang ? dom.div('Programming language(s): ' + s.ProgLang) : [],
			dom.div('Kind: ', Object.entries({ Server: s.Server, Service: s.Service, Library: s.Library, Client: s.Client, Desktop: s.Desktop, Mobile: s.Mobile, Web: s.Web, Terminal: s.Terminal }).filter(t => t[1]).map(t => t[0]).join(', ')),
		] : []))), features.map(f => dom.tr(detailsFeatures.checked ? dom.td(style({ maxWidth: '20em', fontSize: '.8em' }), showIDs.checked ? dom.div(f.Title) : dom.div('ID: ' + f.ID), f.Description ? dom.div(f.Description) : []) : [], dom.td(dom._class('feature'), function click() {
			featurePopup(f, state, render);
		}, dom.span(showIDs.checked ? f.ID : f.Title, attr.title(featureSummary(f))), f.URL ? [' ', dom.a(style({ fontSize: '.8em' }), attr.href(f.URL), attr.rel('noopener'), attr.title('Open website'), 'ð')] : []), software.map(s => makeStatus(s, f))))));
		table.replaceWith(ntable);
		table = ntable;
	};
	dom._kids(document.body, dom.div(dom.div(style({ padding: '.5em' }), search = dom.input(attr.placeholder('Free-form feature search...'), function change() { changed(); }), ' ', dom.span('Filters: ', attr.title('Filter displayed features and software. Useful for making manageable views for certain type of software, or aspects of implementations (feature sets).')), dom.label(filterServer = dom.input(attr.type('checkbox'), function change() { changed(); }), ' Server'), ' ', dom.label(filterService = dom.input(attr.type('checkbox'), function change() { changed(); }), ' Service'), ' ', dom.label(filterLibrary = dom.input(attr.type('checkbox'), function change() { changed(); }), ' Library'), ' ', dom.label(filterClient = dom.input(attr.type('checkbox'), function change() { changed(); }), ' Client'), ' ', dom.label(filterDesktop = dom.input(attr.type('checkbox'), function change() { changed(); }), ' Desktop'), ' ', dom.label(filterMobile = dom.input(attr.type('checkbox'), function change() { changed(); }), ' Mobile'), ' ', dom.label(filterWeb = dom.input(attr.type('checkbox'), function change() { changed(); }), ' Web'), ' ', dom.label(filterTerminal = dom.input(attr.type('checkbox'), function change() { changed(); }), ' Terminal'), ' ', dom.label(filterOpenSource = dom.input(attr.type('checkbox'), function change() { changed(); }), ' Open Source'), ' ', dom.label(filterUnmaintained = dom.input(attr.type('checkbox'), function change() { changed(); }), ' Show unmaintained', attr.title('By default, only maintained software is shown.')), ' ', featureMatch = dom.input(attr.placeholder('Regexp on feature IDs...'), function change() { changed(); }), ' ', softwareIDs = dom.input(attr.placeholder('Software IDs, comma-separate...'), function change() { changed(); }), ' ', 'Show details: ', dom.label(detailsFeatures = dom.input(attr.type('checkbox'), function change() { changed(); }), ' Features', attr.title('Displays extra column with details about each feature.')), ' ', dom.label(detailsSoftware = dom.input(attr.type('checkbox'), function change() { changed(); }), ' Software', attr.title('Displays extra row with details about each software package.')), ' ', dom.clickbutton('About', function click() {
		popup(style({ maxWidth: '50em' }), dom.h1('Implementations'), dom.p("This page allows tracking software and their features. Features can be protocols and standards, or behaviours. Software exists in various forms: servers vs clients, libraries vs applications, desktop vs mobile vs web vs terminal."), dom.p("The goal is keep an overview of software that implements (or does not implement) certain protocols/standards. This is useful for developers when they want to test for interoperability. It may also prove useful in the future to coordinate moving the ecosystem forward."), dom.p("Use the filters to drill down to the relevant software and/or features. Hit return in a text field after changing it to apply the updated filters."), dom.p("Anyone can make changes. Please stick to the suggested naming schemes, or the database will become a mess. Information does not have to be complete, don't skip making changes because you don't have (time to gather more) complete information. Time will tell how this information is used and how complete it should be."), dom.p('Making a good ontology of "features" is a difficult task. Different users have different needs. It may be good to differentiate between standards/protocols and optional/required behaviours, and between behaviours that applications choose on their own.'), dom.p('Add/remove/edit features and software. Click on a cell in the matrix/table to change the implementation status of a feature for the software. Use the "paint status" function to quickly set many statuses. Keyboard keys 1 and onwards select a status. Escape cancels.'), dom.p('The data is licensed under ', dom.a(attr.href('https://creativecommons.org/publicdomain/zero/1.0/'), attr.rel('noopener'), 'CC0'), ', i.e. public domain. The ', dom.a(attr.href('https://github.com/modern-email/implementations'), attr.rel('noopener'), 'code'), ' is licensed under MIT license. Download current database as ', dom.a(attr.href('implementations.json'), 'implementations.json'), ' for use outside this tool, or as ', dom.a(attr.href('implementations.db'), 'implementations.db'), ' for use with a local version of this tool.'));
	}), ' ', paint = dom.select(style({ position: 'fixed', right: '1em' }), attr.title('Select a status to switch to a mode where every click in the matrix saves the status. A quick way to make many changes. Use keyboard shortcuts from 1 onwards to enable a status, and Escape to disable.'), function change() { paintChanged(); }, dom.option('Paint status...', attr.value('')), dom.option('Yes'), dom.option('Partial'), dom.option('Planned'), dom.option('No'), dom.option('Never'), dom.option('N/A', attr.value('n/a')), dom.option('Unknown', attr.value('?')))), table = dom.table()));
	window.addEventListener('hashchange', () => {
		loadFromHash();
		render();
	});
	loadFromHash();
	render();
	let styleElem = dom.style('td.status { cursor: crosshair !important; }');
	let statusPaint;
	const paintChanged = () => {
		if (paint.value) {
			if (!statusPaint) {
				document.head.appendChild(styleElem);
			}
			statusPaint = paint.value === '?' ? api.Status.Unknown : paint.value;
		}
		else {
			statusPaint = undefined;
			styleElem.remove();
		}
	};
	const statusKeys = {
		'1': api.Status.Yes,
		'2': api.Status.Partial,
		'3': api.Status.Planned,
		'4': api.Status.No,
		'5': api.Status.Never,
		'6': api.Status.NotApplicable,
		'7': api.Status.Unknown,
	};
	document.addEventListener('keyup', (e) => {
		if (e.key in statusKeys) {
			paint.value = statusKeys[e.key] || '?';
			paintChanged();
		}
		else if (statusPaint && e.code === 'Escape') {
			paint.value = '';
			paintChanged();
		}
	});
};
window.addEventListener('load', async () => {
	try {
		await init();
	}
	catch (err) {
		window.alert('Error: ' + errmsg(err));
	}
});
